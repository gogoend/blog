<!-- 依赖追踪 -->
<script type="module">
window.__MyVue__ = {}

//#region
function isObject () {
    return val !== null && typeof val === 'object'
}
function hasOwn (o, key) {
    return Object.prototype.hasOwnProperty.call(
        o,
        key
    )
}
//#endregion

//#region
function track (target, type, key) {

}
function trigger (target, type, key) {

}
//#endregion

const reactiveMap = new WeakMap()
window.__MyVue__.reactiveMap = reactiveMap

const ReactiveFlags = {
    IS_REACTIVE: Symbol('__v_isReactive'),
    RAW: Symbol('__v_raw')
}

const mutableHandlers = {
    get (target, key, receiver) {
        const isExistedMap = () => key === ReactiveFlags.RAW && receiver === reactiveMap.get(target)

        if (key === ReactiveFlags.IS_REACTIVE) return true
        else if (isExistedMap()) return target

        const result = Reflect.get(target, key, receiver)
        track(target, 'get', key)

        return res
    },
    set (target, key, value, receiver) {
        const result = Reflect.set(target, key, value, receiver)
        trigger(target, 'set', key)

        return result
    }
}
function reactive (target) {
    return createReactiveObject(
        target,
        reactiveMap,
        mutableHandlers
    )
}
window.__MyVue__.reactive = reactive

function isReactive(value) {
    return !!value[ReactiveFlags.IS_REACTIVE]
}

// 这里除了考虑reactive外还额外考虑shallowReactive，因此通过传参的方式处理，以便复用
function createReactiveObject (target, proxyMap, proxyHandlers) {
    if (!target || typeof target !== 'object') {
        return target
    }

    const existedProxy = proxyMap.get(target)
    if (existedProxy) {
        return existedProxy
    }

    const proxy = new Proxy(
        target,
        proxyHandlers
    )
    reactiveMap.set(target, proxy)

    return proxy
}
</script>

<script type="module">
// CASE
window.a = window.__MyVue__.reactive({
    b: 1,
    c: 2,
    d: {
        e: 3,
        f: 4,
        g: {
            h: 5
        }
    }
})

</script>