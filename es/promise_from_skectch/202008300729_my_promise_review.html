<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise 重写测试</title>
</head>
<body>
    <script>
        let Opromise = window.Promise
        let PENDING = 'pending', FULFILLED = 'fulfilled', REJECTED = 'rejected'
        Promise = function (func) {
            let _this = this
            this.val = undefined
            this.status = PENDING

            this.fulfilledCbs = []
            this.rejectedCbs = []
            let resolve, _resolve = function (val) {
                // TODO: 这里的得到 上一步的返回值 可以是任意类型的值，需要对该值类型进行判断，以进行对应操作
                // 若返回了Promise对象或是带有then方法的对象，需要执行then

                // …… 
                setTimeout(function () {
                    if (_this.status === PENDING) {
                        _this.val = val
                        _this.status = FULFILLED
                        _this.fulfilledCbs.forEach(fun => {
                            fun(val)
                        });
                    }
                })
            }
            let reject, _reject = function (val) {
                setTimeout(function () {
                    if (_this.status === REJECTED) {
                        _this.reason = reason
                        _this.status = REJECTED
                        _this.rejectedCbs.forEach(fun => {
                            fun(reason)
                        });
                    }
                })
            }
            resolve = _resolve.bind(_this)
            reject = _reject.bind(_this)

            // 以上仅仅是定义，此处才是调用
            // 而且在Promise初始化后立即调用传入的函数
            try {
                func(resolve, reject)
            } catch (err) {
                reject(err)
            }
        }
        Promise.prototype = {
            // then应当返回Promise实例
            then: function (onFulfilledCb, onRejectedCb) {
                let _this = this
                let status = this.status

                let promise2 = new Promise((resolve, reject) => {
                    if (status === PENDING) {
                        _this.fulfilledCbs.push(
                            function(val){
                                setTimeout(function(){
                                    try{
                                        // TODO: 这里的得到 x 可以是任意类型的值，需要对该值类型进行判断，以进行对应操作
                                        let x = onFulfilledCb(val)
                                        resolve(x)
                                    }catch(err){
                                        reject(err)
                                    }
                                })
                            }
                        )
                        _this.rejectedCbs.push(
                            function(val){
                                setTimeout(function(){
                                    try{
                                        // TODO: 这里的得到 x 可以是任意类型的值，需要对该值类型进行判断，以进行对应操作
                                        let x = onRejectedCb(val)
                                        resolve(x)
                                    } catch(err){
                                        reject(err)
                                    }
                                })
                            }
                        )
                    }
                    if (status === FULFILLED) {
                        setTimeout(function(val){
                            try{
                                // TODO: 这里的得到 x 可以是任意类型的值，需要对该值类型进行判断，以进行对应操作
                                let x = onFulfilledCb(val)
                                resolve(x)
                            } catch (err){
                                reject(err)
                            }
                        })
                    }
                    if (status === REJECTED) {
                        setTimeout(function(reason){
                            try {
                                // TODO: 这里的得到 x 可以是任意类型的值，需要对该值类型进行判断，以进行对应操作
                                let x = onRejectedCb(reason)
                                resolve(x)
                            }catch(err){
                                reject(err)
                            }
                        })
                    }
                })
                // 返回一个Promise以供接下来的Promise链式调用、
                return promise2
            }
        }
    </script>
</body>

</html>